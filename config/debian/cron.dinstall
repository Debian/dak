#!/bin/bash
# No way I try to deal with a crippled sh just for POSIX foo.

# Copyright (C) 2009-2012 Joerg Jaspert <joerg@debian.org>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; version 2.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

# Homer: Are you saying you're never going to eat any animal again? What
#        about bacon?
# Lisa: No.
# Homer: Ham?
# Lisa: No.
# Homer: Pork chops?
# Lisa: Dad, those all come from the same animal.
# Homer: Heh heh heh. Ooh, yeah, right, Lisa. A wonderful, magical animal.

# exit on errors
set -e
set -o pipefail
# make sure to only use defined variables
set -u
# ERR traps should be inherited from functions too. (And command
# substitutions and subshells and whatnot, but for us the functions is
# the important part here)
set -E

# import the general variable set.
export SCRIPTVARS=/srv/ftp-master.debian.org/dak/config/debian/vars
. $SCRIPTVARS

########################################################################
# Functions                                                            #
########################################################################
# common functions are "outsourced"
. "${configdir}/common"

# source the dinstall functions
. "${configdir}/dinstall.functions"

########################################################################
########################################################################

# Function to save which stage we are in, so we can restart an interrupted
# dinstall. Or even run actions in parallel, if we dare to, by simply
# backgrounding the call to this function. But that should only really be
# done for things we don't care much about.
#
# This should be called with the first argument being an array, with the
# members
#  - FUNC - the function name to call
#  - ARGS - Possible arguments to hand to the function. Can be the empty string
#  - TIME - The timestamp name. Can be the empty string
#  - ERR  - if this is the string false, then the call will be surrounded by
#           set +e ... set -e calls, so errors in the function do not exit
#           dinstall. Can be the empty string, meaning true.
#
# MAKE SURE TO KEEP THIS THE LAST FUNCTION, AFTER ALL THE VARIOUS ONES
# ADDED FOR DINSTALL FEATURES!
function stage() {
    ARGS='GO[@]'
    local "${!ARGS}"

    local error=${ERR:-"true"}

    ARGS=${ARGS:-""}

    log "########## DINSTALL BEGIN: ${FUNC} ${ARGS} ##########"
    local STAGEFILE="${stagedir}/${FUNC}_${ARGS}"
    STAGEFILE=${STAGEFILE// /_}
    if [ -f "${STAGEFILE}" ]; then
        local stamptime=$(/usr/bin/stat -c %Z "${STAGEFILE}")
        local unixtime=$(date +%s)
        local difference=$(( $unixtime - $stamptime ))
        if [ ${difference} -ge 14400 ]; then
            log_error "Did already run ${FUNC}, stagefile exists, but that was ${difference} seconds ago. Please check."
        else
            log "Did already run ${FUNC}, not calling again..."
        fi
        return
    fi

    debug "Now calling function ${FUNC}. Arguments: ${ARGS}. Timestamp: ${TIME}"

    # Make sure we are always at the same place. If a function wants to be elsewhere,
    # it has to cd first!
    cd ${configdir}

    # Now redirect the output into $STAGEFILE.log. In case it errors out somewhere our
    # errorhandler trap can then mail the contents of $STAGEFILE.log only, instead of a whole
    # dinstall logfile. Short error mails ftw!
    exec >> "${STAGEFILE}.log" 2>&1

    if [ -f "${LOCK_STOP}" ]; then
        log "${LOCK_STOP} exists, exiting immediately"
        exit 42
    fi

    if [ "${error}" = "false" ]; then
        set +e
    fi
    ${FUNC} ${ARGS}

    # No matter what happened in the function, we make sure we have set -e default state back
    set -e

    # Make sure we are always at the same place.
    cd ${configdir}

    # We always use the same umask. If a function wants to do different, fine, but we reset.
    umask 022

    touch "${STAGEFILE}"

    if [ -n "${TIME}" ]; then
        ts "${TIME}"
    fi

    # And the output goes back to the normal logfile
    exec >> "$LOGFILE" 2>&1

    # Now we should make sure that we have a usable dinstall.log, so append the $STAGEFILE.log
    # to it.
    cat "${STAGEFILE}.log" >> "${LOGFILE}"
    rm -f "${STAGEFILE}.log"

    log "########## DINSTALL END: ${FUNC} ##########"

    if [ -f "${LOCK_STOP}" ]; then
        log "${LOCK_STOP} exists, exiting immediately"
        exit 42
    fi
}

########################################################################

# We need logs.
LOGFILE="$logdir/dinstall.log"

exec >> "$LOGFILE" 2>&1

# And now source our default config
. "${configdir}/dinstall.variables"

# Make sure we start out with a sane umask setting
umask 022

# And use one locale, no matter what the caller has set
export LANG=C
export LC_ALL=C

touch "${DINSTALLSTART}"
ts "startup"
DINSTALLBEGIN="$(date -u +"%a %b %d %T %Z %Y (%s)")"
state "Startup"

lockfile -l 3600 "${LOCK_DAILY}"
trap onerror ERR
trap remove_daily_lock EXIT TERM HUP INT QUIT

touch "${LOCK_BRITNEY}"

# This loop simply wants to be fed by a list of values (see below)
# which consists of 5 values currently.
# The first four are the array values for the stage function, the
# fifths tells us if we should background the stage call.
#
#  - FUNC - the function name to call
#  - ARGS - Possible arguments to hand to the function. Can be the empty string
#  - TIME - The timestamp name. Can be the empty string
#  - ERR  - if this is the string false, then the call will be surrounded by
#           set +e ... set -e calls, so errors in the function do not exit
#           dinstall. Can be the empty string, meaning true.
#  - BG   - Background the function stage?
#
# ATTENTION: Spaces in arguments or timestamp names need to be escaped by \
#
# ATTENTION: There are two special values for the first column (FUNC).
#            STATE   - do not call stage function, call the state
#                      function to update the public statefile "where is dinstall"
#            NOSTAGE - do not call stage function, call the command directly.
while read FUNC ARGS TIME ERR BACKGROUND; do
    debug "FUNC: $FUNC ARGS: $ARGS TIME: $TIME ERR: $ERR BG: $BACKGROUND"

    # Empty values in the value list are the string "none" (or the
    # while read loop won't work). Here we ensure that variables that
    # can be empty, are empty if the string none is set for them.
    for var in ARGS TIME; do
        if [[ ${!var} == none ]]; then
            typeset ${var}=''
        fi
    done

    case ${FUNC} in
        STATE)
            state ${ARGS}
        ;;
        NOSTAGE)
            ${ARGS}
        ;;
        *)
            GO=(
                FUNC=${FUNC}
                TIME=${TIME}
                ARGS=${ARGS}
                ERR=${ERR}
            )
            if [[ ${BACKGROUND} == true ]]; then
                stage $GO &
            else
                stage $GO
            fi
        ;;
    esac
done < <(cat - <<EOF
savetimestamp          none                       none                       false   false
qa1                    none                       init                       true    true
pg_timestamp           predinstall                pg_dump1                   false   false
updates                none                       External\ Updates          false   false
i18n1                  none                       i18n\ 1                    false   false
dep11                  none                       dep11\ 1                   false   false
NOSTAGE                lockaccepted               none                       false   false
punew                  stable-new                 p-u-new                    false   false
opunew                 oldstable-new              o-p-u-new                  false   false
backports_policy       none                       backports-policy           false   false
cruft                  none                       cruft                      false   false
STATE                  indices                    none                       false   false
dominate               none                       dominate                   false   false
autocruft              none                       autocruft                  false   false
fingerprints           none                       import-keyring             false   false
overrides              none                       overrides                  false   false
mpfm                   none                       pkg-file-mapping           false   false
STATE                  packages/contents          none                       false   false
packages               none                       apt-ftparchive             false   false
STATE                  dists/                     none                       false   false
pdiff                  none                       pdiff                      false   false
release                none                       release\ files             false   false
dakcleanup             none                       cleanup                    false   false
STATE                  scripts                    none                       false   false
mkmaintainers          none                       mkmaintainers              false   false
copyoverrides          none                       copyoverrides              false   false
mklslar                none                       mklslar                    false   false
mkfilesindices         none                       mkfilesindices             false   false
mkchecksums            none                       mkchecksums                false   false
mirror                 none                       mirror\ hardlinks          false   false
NOSTAGE                remove_locks               none                       false   false
STATE                  postlock                   none                       false   false
ddaccess               none                       ddaccessible\ sync         true    true
changelogs             none                       changelogs                 false   true
pg_timestamp           postdinstall               pg_dump2                   false   false
expire                 none                       expire_dumps               false   true
transitionsclean       none                       transitionsclean           false   true
dm                     none                       none                       false   true
bts                    none                       none                       false   true
mirrorpush             none                       mirrorpush                 false   true
mirrorpush-backports   none                       mirrorpush-backports       false   true
i18n2                  none                       i18n\ 2                    false   true
stats                  none                       stats                      false   true
testingsourcelist      none                       none                       false   true
NOSTAGE                rm\ -f\ "\${LOCK_BRITNEY}" none                       false   false
cleantransactions      none                       none                       false   false
EOF
        )

# we need to wait for the background processes before the end of dinstall
wait

log "Daily cron scripts successful, all done"

exec > "$logdir/afterdinstall.log" 2>&1

GO=(
    FUNC="renamelogfile"
    TIME=""
    ARGS=""
    ERR="false"
)
stage $GO
state "all done"


# Now, at the very (successful) end of dinstall, make sure we remove
# our stage files, so the next dinstall run will do it all again.
rm -f ${stagedir}/*
touch "${DINSTALLEND}"
